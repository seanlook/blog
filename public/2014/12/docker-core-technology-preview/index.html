<!DOCTYPE html>
<html lang="en" dir="auto">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="noindex, nofollow">
<title>【转&#43;改】Docker核心技术预览 | Sean&#39;s Note</title>
<meta name="keywords" content="docker, linux, lxc, cgroup, aufs">
<meta name="description" content="本文简单介绍docker使用到的部分核心技术，但不做深入探究，因为每一个技术都是一个独立的项目，有机会再分别详细介绍。
来源地址：http://www.infoq.com/cn/articles/docker-core-technology-preview">
<meta name="author" content="">
<link rel="canonical" href="http://localhost:1313/2014/12/docker-core-technology-preview/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.8a19d6c7d40c68078a482516c7c2a326ccb9f6e9282cabe7240ecc1a80c6cb47.css" integrity="sha256-ihnWx9QMaAeKSCUWx8KjJsy59ukoLKvnJA7MGoDGy0c=" rel="preload stylesheet" as="style">
<link rel="icon" href="http://localhost:1313/img/logo.gif">
<link rel="icon" type="image/png" sizes="16x16" href="http://localhost:1313/img/logo.gif">
<link rel="icon" type="image/png" sizes="32x32" href="http://localhost:1313/img/logo.gif">
<link rel="apple-touch-icon" href="http://localhost:1313/logo.gif">
<link rel="mask-icon" href="http://localhost:1313/logo.gif">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="http://localhost:1313/2014/12/docker-core-technology-preview/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="http://localhost:1313/" accesskey="h" title="Sean&#39;s Note (Alt + H)">Sean&#39;s Note</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://localhost:1313/about/" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="http://localhost:1313/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="http://localhost:1313/">Home</a>&nbsp;»&nbsp;<a href="http://localhost:1313/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      【转&#43;改】Docker核心技术预览
    </h1>
    <div class="post-meta"><span title='2014-12-18 13:21:25 +0000 UTC'>2014-12-18</span>&nbsp;·&nbsp;10 min

</div>
  </header> <aside id="toc-container" class="toc-container wide">
    <div class="toc">
        <details  open>
            <summary accesskey="c" title="(Alt + C)">
                <span class="details">Table of Contents</span>
            </summary>

            <div class="inner"><ul>
                    <li>
                        <a href="#linux-namespace-%e5%ae%9e%e4%be%8b%e9%9a%94%e7%a6%bb" aria-label="Linux Namespace （实例隔离）##">Linux Namespace （实例隔离）##</a></li>
                    <li>
                        <a href="#cgroup-%e8%b5%84%e6%ba%90%e9%85%8d%e9%a2%9d" aria-label="cgroup （资源配额）">cgroup （资源配额）</a></li>
                    <li>
                        <a href="#lxclinux-container" aria-label="LXC（LinuX Container）">LXC（LinuX Container）</a></li>
                    <li>
                        <a href="#aufs" aria-label="AUFS">AUFS</a></li>
                    <li>
                        <a href="#%e5%85%a8%e6%96%87%e5%8f%82%e8%80%83" aria-label="全文参考">全文参考</a>
                    </li>
                </ul>
            </div>
        </details>
    </div>
</aside>
<script>
    let activeElement;
    let elements;
    window.addEventListener('DOMContentLoaded', function (event) {
        checkTocPosition();

        elements = document.querySelectorAll('h1[id],h2[id],h3[id],h4[id],h5[id],h6[id]');
         
         activeElement = elements[0];
         const id = encodeURI(activeElement.getAttribute('id')).toLowerCase();
         document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
     }, false);

    window.addEventListener('resize', function(event) {
        checkTocPosition();
    }, false);

    window.addEventListener('scroll', () => {
        
        activeElement = Array.from(elements).find((element) => {
            if ((getOffsetTop(element) - window.pageYOffset) > 0 && 
                (getOffsetTop(element) - window.pageYOffset) < window.innerHeight/2) {
                return element;
            }
        }) || activeElement

        elements.forEach(element => {
             const id = encodeURI(element.getAttribute('id')).toLowerCase();
             if (element === activeElement){
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.add('active');
             } else {
                 document.querySelector(`.inner ul li a[href="#${id}"]`).classList.remove('active');
             }
         })
     }, false);

    const main = parseInt(getComputedStyle(document.body).getPropertyValue('--article-width'), 10);
    const toc = parseInt(getComputedStyle(document.body).getPropertyValue('--toc-width'), 10);
    const gap = parseInt(getComputedStyle(document.body).getPropertyValue('--gap'), 10);

    function checkTocPosition() {
        const width = document.body.scrollWidth;

        if (width - main - (toc * 2) - (gap * 4) > 0) {
            document.getElementById("toc-container").classList.add("wide");
        } else {
            document.getElementById("toc-container").classList.remove("wide");
        }
    }

    function getOffsetTop(element) {
        if (!element.getClientRects().length) {
            return 0;
        }
        let rect = element.getBoundingClientRect();
        let win = element.ownerDocument.defaultView;
        return rect.top + win.pageYOffset;   
    }
</script>


  <div class="post-content"><p>本文简单介绍docker使用到的部分核心技术，但不做深入探究，因为每一个技术都是一个独立的项目，有机会再分别详细介绍。
来源地址：http://www.infoq.com/cn/articles/docker-core-technology-preview</p>
<p><img alt="docker-core-tech" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/docker-core-tech.png"></p>
<h2 id="linux-namespace-实例隔离">Linux Namespace （实例隔离）##<a hidden class="anchor" aria-hidden="true" href="#linux-namespace-实例隔离">#</a></h2>
<blockquote>
<p>The purpose of each namespace is to wrap a particular global system resource in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource.</p></blockquote>
<p>每个用户实例之间相互隔离，互不影响。一般的硬件虚拟化方法给出的方法是VM，而LXC给出的方法是container，更细一点讲就是kernel namespace。其中pid、net、ipc、mnt、uts、user等namespace将container的进程、网络、消息、文件系统、UTS(&ldquo;UNIX Time-sharing System&rdquo;)和用户空间隔离开。</p>
<ul>
<li><strong>pid namespace</strong></li>
</ul>
<p>不同用户的进程就是通过pid namespace隔离开的，且不同 namespace 中可以有相同pid。所有的LXC进程在docker中的父进程为docker进程，每个lxc进程具有不同的namespace。同时由于允许嵌套，因此可以很方便的实现 Docker in Docker。</p>
<p><img alt="docker-kernel-pid-namespace.png" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/docker-kernel-pid-namespace.png"></p>
<ul>
<li>** net namespace **</li>
</ul>
<p>有了 pid namespace, 每个namespace中的pid能够相互隔离，但是网络端口还是共享host的端口。网络隔离是通过net namespace实现的， 每个net namespace有独立的 network devices, IP addresses, IP routing tables, <code>/proc/net</code> 目录。这样每个container的网络就能隔离开来。LXC在此基础上有5种网络类型，docker默认采用veth的方式将container中的虚拟网卡同host上的一个docker bridge—docker0连接在一起。</p>
<ul>
<li>** ipc namespace **</li>
</ul>
<p>container中进程交互还是采用linux常见的进程间交互方法(interprocess communication - IPC), 包括常见的信号量、消息队列和共享内存。然而与VM不同，container 的进程间交互实际上还是host上具有相同pid namespace中的进程间交互，因此需要在IPC资源申请时加入namespace信息 - 每个IPC资源有一个唯一的 32bit ID。</p>
<ul>
<li>** mnt namespace **</li>
</ul>
<p>类似<code>chroot</code>，将一个进程放到一个特定的目录执行。mnt namespace允许不同namespace的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了。同<code>chroot不同，每个namespace中的container在</code>/proc/mounts`的信息只包含所在namespace的mount point。</p>
<ul>
<li>** uts namespace **</li>
</ul>
<p>UTS(&ldquo;UNIX Time-sharing System&rdquo;) namespace允许每个container拥有独立的hostname和domain name, 使其在网络上可以被视作一个独立的节点而非Host上的一个进程。</p>
<ul>
<li>** user namespace **</li>
</ul>
<p>每个container可以有不同的 user 和 group id, 也就是说可以以container内部的用户在container内部执行程序而非Host上的用户。</p>
<p>有了以上6种namespace从进程、网络、IPC、文件系统、UTS和用户角度的隔离，一个container就可以对外展现出一个独立计算机的能力，并且不同container从OS层面实现了隔离。 然而不同namespace之间资源还是相互竞争的，仍然需要类似ulimit来管理每个container所能使用的资源——LXC 采用的是cgroup。</p>
<p><strong>参考</strong></p>
<ul>
<li><a href="http://blog.dotcloud.com/under-the-hood-linux-kernels-on-dotcloud-part">PaaS under the hood, episode 1: kernel namespaces</a>， <a href="https://github.com/dockercn/docs/blob/master/paas-under-the-hood-episode-1-kernel-namespaces.md">[中文]</a></li>
<li><a href="http://blog.blackwhite.tw/2013/12/docker.html">http://blog.blackwhite.tw/2013/12/docker.html</a></li>
</ul>
<h2 id="cgroup-资源配额">cgroup （资源配额）<a hidden class="anchor" aria-hidden="true" href="#cgroup-资源配额">#</a></h2>
<p>cgroups 实现了对资源的配额和度量。cgroups 的使用非常简单，提供类似文件的接口，在 <code>/cgroup</code>目录下新建一个文件夹即可新建一个group，在此文件夹中新建<code>task</code>文件，并将pid写入该文件，即可实现对该进程的资源控制。具体的资源配置选项可以在该文件夹中新建子<code>subsystem</code>，<code>{子系统前缀}.{资源项}</code> 是典型的配置方法， 如<code>memory.usage_in_bytes</code>就定义了该group 在subsystem memory中的一个内存限制选项。</p>
<p>我们主要关心cgroups可以限制哪些资源，即有哪些subsystem是我们关心。</p>
<ul>
<li>
<p><strong>cpu</strong>
在cgroup中，并不能像硬件虚拟化方案一样能够定义CPU能力，但是能够定义CPU轮转的优先级，因此具有较高CPU优先级的进程会更可能得到CPU运算。 通过将参数写入cpu.shares,即可定义改cgroup的CPU优先级 - 这里是一个相对权重，而非绝对值。当然在cpu这个subsystem中还有其他可配置项，手册中有详细说明。</p>
</li>
<li>
<p><strong>cpuacct</strong>
产生cgroup任务的cpu资源报告</p>
</li>
<li>
<p><strong>cpuset</strong>
cpusets 定义了有几个CPU可以被这个group使用，或者哪几个CPU可以供这个group使用。在某些场景下，单CPU绑定可以防止多核间缓存切换，从而提高效率</p>
</li>
<li>
<p><strong>memory</strong>
设置每个cgroup的内存限制以及产生内存资源报告</p>
</li>
<li>
<p><strong>blkio</strong>
block IO相关的统计和限制，byte/operation统计和限制(IOPS等)，读写速度限制等，但是这里主要统计的都是同步IO</p>
</li>
<li>
<p><strong>net_cls</strong>
标记每个网络包以供cgroup方便使用</p>
</li>
<li>
<p><strong>devices</strong>
允许或拒绝cgroup任务对设备的访问</p>
</li>
<li>
<p><strong>freezer</strong>
暂停和恢复cgroup任务</p>
</li>
</ul>
<p><strong>参考</strong></p>
<ul>
<li><a href="http://blog.dotcloud.com/kernel-secrets-from-the-paas-garage-part-24-c">PaaS Under the Hood, Episode 2: cgroups</a></li>
<li><a href="https://www.kernel.org/doc/Documentation/cgroups/">https://www.kernel.org/doc/Documentation/cgroups/</a></li>
<li><a href="http://en.wikipedia.org/wiki/Cgroups">http://en.wikipedia.org/wiki/Cgroups</a></li>
</ul>
<h2 id="lxclinux-container">LXC（LinuX Container）<a hidden class="anchor" aria-hidden="true" href="#lxclinux-container">#</a></h2>
<blockquote>
<p>LXC (LinuX Container) is an operating system-level virtualization method for running multiple isolated Linux systems (containers) on a single control host. This is accomplished through kernel level isolation.</p></blockquote>
<p>借助于namespace的隔离机制和cgroup限额功能，LXC提供了一套统一的API和工具来建立和管理container，LXC利用了如下 kernel 的特性：</p>
<ul>
<li>Kernel namespaces (ipc, uts, mount, pid, network and user)</li>
<li>Apparmor and SELinux profiles (security)</li>
<li>Seccomp policies</li>
<li>Chroots (using pivot_root)</li>
<li>Kernel capabilities</li>
<li>Control groups (cgroups)</li>
</ul>
<p>LXC 旨在提供一个共享kernel的 OS 级虚拟化方法，在执行时不用重复加载Kernel，且container的kernel与host共享，因此可以大大加快container的 启动过程，并显著减少内存消耗。</p>
<p>这篇<a href="http://stackoverflow.com/questions/17989306/what-does-docker-add-to-just-plain-lxc">stackoverflow</a>上的问题和答案很好地诠释了Docker和LXC的区别，能够让你更好的了解什么是Docker， 简单翻译下就是以下几点：</p>
<ol>
<li>Portable deployment across machines
Docker提供了一种可移植的配置标准化机制，允许你一致性地在不同的机器上运行同一个Container；而LXC本身可能因为不同机器的不同配置而无法方便地移植运行；</li>
<li>Application-centric
Docker以App为中心，为应用的部署做了很多优化，而LXC的帮助脚本主要是聚焦于如何机器启动地更快和耗更少的内存；</li>
<li>Automatic build
Docker为App提供了一种自动化构建机制（Dockerfile），包括打包，基础设施依赖管理和安装等等；</li>
<li>Versioning
Docker提供了一种类似git的Container版本化的机制，允许你对你创建过的容器进行版本管理，依靠这种机制，你还可以下载别人创建的Container，甚至像git那样进行合并；</li>
<li>Component reuse
Docker Container是可重用的，依赖于版本化机制，你很容易重用别人的Container（叫Image），作为基础版本进行扩展；</li>
<li>Sharing
Docker Container是可共享的，有点类似github一样，Docker有自己的INDEX，你可以创建自己的Docker用户并上传和下载Docker Image；</li>
<li>Tool ecosystem
Docker提供了很多的工具链，形成了一个生态系统；这些工具的目标是自动化、个性化和集成化，包括对PAAS平台的支持等。</li>
</ol>
<p><strong>参考</strong></p>
<ul>
<li><a href="http://linuxcontainers.org/">http://linuxcontainers.org/</a></li>
<li><a href="http://en.wikipedia.org/wiki/LXC">http://en.wikipedia.org/wiki/LXC</a></li>
<li><a href="http://marceloneves.org/papers/pdp2013-containers.pdf">http://marceloneves.org/papers/pdp2013-containers.pdf</a> (性能测试)</li>
<li><a href="http://article.sciencepublishinggroup.com/pdf/10.11648.j.ajnc.20130204.11.pdf">http://article.sciencepublishinggroup.com/pdf/10.11648.j.ajnc.20130204.11.pdf</a></li>
</ul>
<h2 id="aufs">AUFS<a hidden class="anchor" aria-hidden="true" href="#aufs">#</a></h2>
<p>Docker对container的使用基本是建立在LXC基础之上的，然而LXC存在的问题是难以移动——难以通过标准化的模板制作、重建、复制和移动 container。在以VM为基础的虚拟化手段中，有image和snapshot可以用于VM的复制、重建以及移动的功能。想要通过container来实现快速的大规模部署和更新, 这些功能不可或缺。Docker正是利用AUFS来实现对container的快速更新——在docker0.7中引入了storage driver, 支持AUFS, VFS, device mapper, 也为BTRFS以及ZFS引入提供了可能。</p>
<p>AUFS (Another Union FS) 是一种 Union FS，简单来说就是支持将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)的文件系统, 更进一步的理解, AUFS支持为每一个成员目录（类似Git Branch）设定readonly、readwrite 和 whiteout-able 权限, 同时 AUFS 里有一个类似分层的概念, 对 readonly 权限的 branch 可以逻辑上进行修改(增量地, 不影响 readonly 部分的)。通常 Union FS 有两个用途, 一方面可以实现不借助 LVM、RAID 将多个disk挂到同一个目录下, 另一个更常用的就是将一个 readonly 的 branch 和一个 writeable 的 branch 联合在一起，Live CD正是基于此方法可以允许在 OS image 不变的基础上允许用户在其上进行一些写操作。Docker 在 AUFS 上构建的 container image 也正是如此，接下来我们从启动 container 中的 linux 为例来介绍 docker 对AUFS特性的运用。</p>
<p>典型的启动Linux运行需要两个FS: bootfs + rootfs：</p>
<p><img alt="docker-filesystems-generic" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/docker-filesystems-generic.png"></p>
<p>bootfs（boot file system）主要包含 bootloader 和 kernel, bootloader主要是引导加载kernel, 当boot成功后 kernel 被加载到内存中后 bootfs就被umount了。rootfs (root file system) 包含的就是典型 Linux 系统中的 <code>/dev</code>, <code>/proc</code>, <code>/bin</code>, <code>/etc</code>等标准目录和文件。</p>
<p>由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs 如下图：</p>
<p><img alt="docker-filesystems-multiroot" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/docker-filesystems-multiroot.png"></p>
<p>典型的Linux在启动后，首先将 rootfs 置为 readonly，进行一系列检查，然后将其切换为 &ldquo;readwrite&rdquo; 供用户使用。在docker中，起初也是将 rootfs 以readonly方式加载并检查，然而接下来利用 union mount 的将一个 readwrite 文件系统挂载在 readonly 的rootfs之上，并且允许再次将下层的 file system设定为readonly 并且向上叠加，这样一组readonly和一个writeable的结构构成一个container的运行目录，每一个被称作一个Layer。如下图：</p>
<p><img alt="docker-filesystems-multilayer" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/docker-filesystems-multilayer.png"></p>
<p>得益于AUFS的特性，每一个对readonly层文件/目录的修改都只会存在于上层的writeable层中。这样由于不存在竞争，多个container可以共享readonly的layer。所以docker将readonly的层称作 &ldquo;image&rdquo;——对于container而言整个rootfs都是read-write的，但事实上所有的修改都写入最上层的writeable层中，image不保存用户状态，可以用于模板、重建和复制。</p>
<p><img alt="docker-filesystems-debian.png" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/docker-filesystems-debian.png">
<img alt="docker-filesystems-debianrw.png" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/docker-filesystems-debianrw.png"></p>
<p>上层的image依赖下层的image，因此docker中把下层的image称作父image，没有父image的image称作base image。</p>
<p>因此想要从一个image启动一个container，docker会先加载其父image直到base image，用户的进程运行在writeable的layer中。所有parent image中的数据信息以及 ID、网络和lxc管理的资源限制等具体container的配置，构成一个docker概念上的container。如下图：</p>
<p><img alt="docker-filesystems-busyboxrw.png" loading="lazy" src="http://github.com/seanlook/sean-notes-comment/raw/main/static/docker-filesystems-busyboxrw.png"></p>
<p>由此可见，采用AUFS作为docker的container的文件系统，能够提供如下好处:</p>
<ol>
<li>节省存储空间：多个container可以共享base image存储</li>
<li>快速部署：如果要部署多个container，base image可以避免多次拷贝</li>
<li>内存更省：因为多个container共享base image, 以及OS的disk缓存机制，多个container中的进程命中缓存内容的几率大大增加</li>
<li>升级更方便：相比于 copy-on-write 类型的FS，base-image也是可以挂载为可writeable的，可以通过更新base image而一次性更新其之上的container</li>
<li>允许在不更改base-image的同时修改其目录中的文件：所有写操作都发生在最上层的writeable层中，这样可以大大增加base image能共享的文件内容。</li>
</ol>
<p>以上5条 1-3 条可以通过 copy-on-write 的FS实现，4可以利用其他的union mount方式实现, 5只有AUFS实现的很好，这也是为什么Docker一开始就建立在AUFS之上。</p>
<p>由于AUFS并不会进入linux主干 (According to Christoph Hellwig, linux rejects all union-type filesystems but UnionMount.), 同时要求kernel版本3.0以上(docker推荐3.8及以上)，因此在RedHat工程师的帮助下在docker0.7版本中实现了driver机制, AUFS只是其中的一个driver, 在RHEL中采用的则是Device Mapper的方式实现的container文件系统。</p>
<p><strong>参考</strong></p>
<ul>
<li><a href="http://blog.dotcloud.com/kernel-secrets-from-the-paas-garage-part-34-a">PAAS Under the Hood, Episode 3: AUFS</a></li>
<li><a href="http://docs.docker.com/terms/layer/">http://docs.docker.com/terms/layer/</a></li>
<li><a href="http://docs.docker.com/terms/filesystem/">http://docs.docker.com/terms/filesystem/</a></li>
</ul>
<h2 id="全文参考">全文参考<a hidden class="anchor" aria-hidden="true" href="#全文参考">#</a></h2>
<ul>
<li>
<p><a href="http://tiewei.github.io/cloud/Docker-Getting-Start/">http://tiewei.github.io/cloud/Docker-Getting-Start/</a></p>
</li>
<li>
<p><a href="https://docker.cn/a/1">https://docker.cn/a/1</a></p>
</li>
<li>
<p><a href="http://blog.dotcloud.com/category/under-the-hood">http://blog.dotcloud.com/category/under-the-hood</a></p>
</li>
<li>
<p><a href="http://www.slideshare.net/BodenRussell/realizing-linux-containerslxc">http://www.slideshare.net/BodenRussell/realizing-linux-containerslxc</a></p>
</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="http://localhost:1313/tags/docker/">Docker</a></li>
      <li><a href="http://localhost:1313/tags/linux/">Linux</a></li>
      <li><a href="http://localhost:1313/tags/lxc/">Lxc</a></li>
      <li><a href="http://localhost:1313/tags/cgroup/">Cgroup</a></li>
      <li><a href="http://localhost:1313/tags/aufs/">Aufs</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="http://localhost:1313/2014/12/docker-shipyard-centralized-management-webui/">
    <span class="title">« Prev</span>
    <br>
    <span>Docker集中化web界面管理平台shipyard</span>
  </a>
  <a class="next" href="http://localhost:1313/2014/12/docker-introduction/">
    <span class="title">Next »</span>
    <br>
    <span>Docker简介</span>
  </a>
</nav>

  </footer><script src="https://utteranc.es/client.js"
        repo="seanlook/sean-notes-comment"
        issue-term="pathname"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="http://localhost:1313/">Sean&#39;s Note</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
